package com.quantumsoft.tia.parsers.zte.core.model

import java.time.Instant
import java.math.BigDecimal

/**
 * ZTE Call Detail Record (CDR) data model representing parsed ASN.1 CDR data.
 * 
 * This data class represents a complete ZTE CDR record with all fields mapped
 * from the ASN.1 structure. The model is designed to be immutable, thread-safe,
 * and optimized for ClickHouse storage with non-nullable fields.
 * 
 * ## Design Principles
 * 
 * - **Immutability**: All fields are immutable for thread safety
 * - **Non-Nullable**: All fields have default values to support non-nullable schema
 * - **Type Safety**: Appropriate Kotlin types for each field category
 * - **Performance**: Optimized field types for ClickHouse storage
 * - **Validation**: Built-in validation through type constraints
 * 
 * ## Field Categories
 * 
 * - **Identity Fields**: Unique identifiers for call sessions
 * - **Subscriber Fields**: Caller and called party information
 * - **Network Fields**: Network routing and service information
 * - **Timing Fields**: Call timing and duration information
 * - **Billing Fields**: Charging and billing related data
 * - **Quality Fields**: Service quality and performance metrics
 * 
 * ## ClickHouse Optimization
 * 
 * Field types are chosen for optimal ClickHouse performance:
 * - String fields use UTF-8 encoding
 * - Numeric fields use appropriate precision
 * - Timestamps use Instant for UTC consistency
 * - Enums use string representation for readability
 * 
 * @author TIA ETL Team
 * @since 1.0.0
 */
data class ZteCdrRecord(
    
    // === Identity Fields ===
    
    /**
     * Unique call identifier generated by ZTE equipment.
     * Primary key for call session tracking and correlation.
     */
    val callId: String = "",
    
    /**
     * Global unique identifier for the call session.
     * Used for correlation across multiple network elements.
     */
    val globalCallId: String = "",
    
    /**
     * Record sequence number within a call session.
     * Supports multi-record calls and proper ordering.
     */
    val sequenceNumber: Long = 0L,
    
    // === Subscriber Information ===
    
    /**
     * Mobile Station ISDN (calling party number).
     * International format without leading + sign.
     */
    val msisdn: String = "",
    
    /**
     * International Mobile Subscriber Identity (calling party).
     * 15-digit identifier uniquely identifying the subscriber.
     */
    val imsi: String = "",
    
    /**
     * Called party number (destination number).
     * May include international prefix and special routing codes.
     */
    val calledNumber: String = "",
    
    /**
     * Mobile Station ISDN of called party (for mobile terminated calls).
     * Empty for calls to non-mobile destinations.
     */
    val calledMsisdn: String = "",
    
    /**
     * International Mobile Subscriber Identity of called party.
     * Populated for mobile-to-mobile calls within the network.
     */
    val calledImsi: String = "",
    
    // === Network Information ===
    
    /**
     * Mobile Switching Center (MSC) address handling the call.
     * Identifies the network node processing the call.
     */
    val mscAddress: String = "",
    
    /**
     * Visited Location Register (VLR) number.
     * Identifies subscriber's current location registration.
     */
    val vlrNumber: String = "",
    
    /**
     * Cell identifier where the call originated.
     * Used for location-based services and network analysis.
     */
    val cellId: String = "",
    
    /**
     * Location Area Code for the originating cell.
     * Higher-level geographic area identifier.
     */
    val locationAreaCode: String = "",
    
    /**
     * Routing number used for call setup.
     * Internal network routing information.
     */
    val routingNumber: String = "",
    
    /**
     * Service type classification.
     * Categories: VOICE, SMS, DATA, VIDEO, etc.
     */
    val serviceType: String = "UNKNOWN",
    
    /**
     * Call type classification.
     * Categories: MOC (Mobile Originating), MTC (Mobile Terminating), etc.
     */
    val callType: String = "UNKNOWN",
    
    // === Timing Information ===
    
    /**
     * Call setup initiation timestamp (UTC).
     * When the call setup process began.
     */
    val callSetupTime: Instant = Instant.EPOCH,
    
    /**
     * Call answer timestamp (UTC).
     * When the called party answered (conversation began).
     */
    val callAnswerTime: Instant = Instant.EPOCH,
    
    /**
     * Call end timestamp (UTC).
     * When the call was terminated by either party.
     */
    val callEndTime: Instant = Instant.EPOCH,
    
    /**
     * Call duration in seconds.
     * Total conversation time (answer to end).
     */
    val callDuration: Long = 0L,
    
    /**
     * Setup duration in seconds.
     * Time from initiation to answer.
     */
    val setupDuration: Long = 0L,
    
    // === Billing Information ===
    
    /**
     * Charged duration in seconds.
     * Duration used for billing calculation (may differ from actual duration).
     */
    val chargedDuration: Long = 0L,
    
    /**
     * Basic service charge amount.
     * Base call charge before additional services.
     */
    val basicServiceCharge: BigDecimal = BigDecimal.ZERO,
    
    /**
     * Additional service charges.
     * Charges for premium services, international routing, etc.
     */
    val additionalServiceCharge: BigDecimal = BigDecimal.ZERO,
    
    /**
     * Total charge amount for the call.
     * Sum of all applicable charges.
     */
    val totalCharge: BigDecimal = BigDecimal.ZERO,
    
    /**
     * Currency code for all charge amounts.
     * ISO 4217 three-letter currency code.
     */
    val chargeCurrency: String = "USD",
    
    /**
     * Charging rate applied to the call.
     * Rate category determining billing calculation.
     */
    val chargingRate: String = "STANDARD",
    
    // === Quality and Performance ===
    
    /**
     * Call completion status.
     * SUCCESS, FAILED, ABANDONED, BUSY, etc.
     */
    val callStatus: String = "UNKNOWN",
    
    /**
     * Call termination cause.
     * Reason for call ending (normal, busy, no answer, etc.).
     */
    val terminationCause: String = "UNKNOWN",
    
    /**
     * Quality of Service indicator.
     * Service quality assessment for the call.
     */
    val qualityOfService: String = "UNKNOWN",
    
    /**
     * Signal strength at call start (dBm).
     * Radio signal quality measurement.
     */
    val signalStrength: Int = -999,
    
    /**
     * Bit error rate during the call.
     * Communication quality metric.
     */
    val bitErrorRate: Double = 0.0,
    
    // === Technical Information ===
    
    /**
     * Bearer service type used for the call.
     * Technical service category (voice, data rate, etc.).
     */
    val bearerService: String = "UNKNOWN",
    
    /**
     * Teleservice type for the call.
     * Higher-level service classification.
     */
    val teleService: String = "UNKNOWN",
    
    /**
     * Supplementary services used during the call.
     * List of additional services (call forwarding, waiting, etc.).
     */
    val supplementaryServices: String = "",
    
    /**
     * Equipment identity (IMEI) of the calling device.
     * Device identifier for fraud detection and tracking.
     */
    val equipmentIdentity: String = "",
    
    /**
     * Software version of the network element.
     * ZTE equipment software version generating this CDR.
     */
    val networkElementVersion: String = "",
    
    // === Record Metadata ===
    
    /**
     * CDR record type identifier.
     * Distinguishes different types of CDR records.
     */
    val recordType: String = "VOICE_CDR",
    
    /**
     * Record generation timestamp (UTC).
     * When this CDR record was created by the network element.
     */
    val recordGenerationTime: Instant = Instant.now(),
    
    /**
     * Processing timestamp (UTC).
     * When this record was processed by the parser.
     */
    val processingTime: Instant = Instant.now(),
    
    /**
     * Source file name containing this record.
     * For tracking and debugging purposes.
     */
    val sourceFile: String = "",
    
    /**
     * Record position within the source file.
     * For debugging and record correlation.
     */
    val recordPosition: Long = 0L
) {
    
    /**
     * Validates the record for basic data integrity.
     * 
     * Performs essential validation checks to ensure the record
     * contains valid data and meets basic business rules.
     * 
     * @return List of validation issues, empty if valid
     */
    fun validateBasicIntegrity(): List&lt;String&gt; {
        val issues = mutableListOf&lt;String&gt;()
        
        // Validate required identity fields
        if (callId.isBlank()) {
            issues.add("Call ID cannot be empty")
        }
        
        // Validate MSISDN format (basic check)
        if (msisdn.isNotBlank() && !msisdn.matches(Regex("^[0-9]{10,15}$"))) {
            issues.add("MSISDN format is invalid: $msisdn")
        }
        
        // Validate IMSI format (basic check)
        if (imsi.isNotBlank() && !imsi.matches(Regex("^[0-9]{15}$"))) {
            issues.add("IMSI format is invalid: $imsi")
        }
        
        // Validate time consistency
        if (callAnswerTime.isAfter(callEndTime) && callEndTime != Instant.EPOCH) {
            issues.add("Call answer time cannot be after call end time")
        }
        
        if (callSetupTime.isAfter(callAnswerTime) && callAnswerTime != Instant.EPOCH) {
            issues.add("Call setup time cannot be after call answer time")
        }
        
        // Validate duration consistency
        if (callDuration &lt; 0) {
            issues.add("Call duration cannot be negative")
        }
        
        if (chargedDuration &lt; 0) {
            issues.add("Charged duration cannot be negative")
        }
        
        // Validate charge amounts
        if (totalCharge &lt; BigDecimal.ZERO) {
            issues.add("Total charge cannot be negative")
        }
        
        return issues
    }
    
    /**
     * Calculates the actual call duration from timestamps.
     * 
     * @return Duration in seconds, or 0 if timestamps are invalid
     */
    fun calculateActualDuration(): Long {
        return if (callAnswerTime != Instant.EPOCH && callEndTime != Instant.EPOCH && callEndTime.isAfter(callAnswerTime)) {
            java.time.Duration.between(callAnswerTime, callEndTime).seconds
        } else {
            0L
        }
    }
    
    /**
     * Checks if this is a successful call completion.
     * 
     * @return true if the call was successfully completed
     */
    fun isSuccessfulCall(): Boolean {
        return callStatus.equals("SUCCESS", ignoreCase = true) && callDuration &gt; 0
    }
    
    /**
     * Gets a summary string for logging and debugging.
     * 
     * @return Concise record summary
     */
    fun toSummary(): String {
        return "CDR[id=$callId, msisdn=$msisdn, type=$callType, duration=${callDuration}s, status=$callStatus]"
    }
    
    /**
     * Creates a copy with updated processing metadata.
     * 
     * @param processingTime New processing timestamp
     * @param sourceFile Source file name
     * @param recordPosition Position within source file
     * @return Updated record copy
     */
    fun withProcessingMetadata(
        processingTime: Instant = Instant.now(),
        sourceFile: String = this.sourceFile,
        recordPosition: Long = this.recordPosition
    ): ZteCdrRecord {
        return copy(
            processingTime = processingTime,
            sourceFile = sourceFile,
            recordPosition = recordPosition
        )
    }
}